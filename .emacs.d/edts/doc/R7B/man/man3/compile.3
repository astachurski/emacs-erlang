.TH compile 3 "compiler  3.0.1" "Ericsson Utvecklings AB" "ERLANG MODULE DEFINITION"
.SH MODULE
compile  \- Erlang Compiler
.SH DESCRIPTION
.LP
This module provides an interface to the standard Erlang compiler\&. It can generate either a new file which contains the object code, or return a binary which can be loaded directly\&. 

.SH EXPORTS
.LP
.B
file(File)
.br
.RS
.LP
Is the same as \fIfile(File, [verbose, report_errors, report_warnings])\fR\&. 
.RE
.LP
.B
file(File, Options) -> CompRet
.br
.RS
.TP
Types
CompRet = ModRet | BinRet | ErrRet
.br
ModRet = {ok, ModuleName} | {ok, ModuleName, Warnings}
.br
BinRet = {ok, ModuleName, Binary} | {ok, ModuleName, Binary, Warnings}
.br
ErrRet = error | {error, Errors, Warnings}
.br
.RE
.RS
.LP
Compiles the code in the file \fIFile\fR, which is an Erlang source code file without the \fI\&.erl\fR extension\&. \fIOptions\fR determine the behavior of the compiler\&. 
.LP
Returns \fI{ok, ModuleName}\fR if successful, or \fIerror\fR if there are errors\&. An object code file is created if the compilation succeeds with no errors\&. 
.LP
As a step in the compilation of Erlang code, \fIerl_lint\fR is run, resulting in warning and error messages, if appropriate\&. The options relevant to the syntactic and semantic controls of \fIerl_lint\fR are listed in the documentation of the module \fIerl_lint\fR\&. 
.LP
The elements of \fIOptions\fR can be selected as follows: 
.RS 2
.TP 4
.B
\fIbinary\fR:
Causes the compiler to return the object code in a binary instead of creating an object file\&. If successful, the compiler returns \fI{ok, ModuleName, Binary}\fR 
.TP 4
.B
\fI\&'P\&'\fR:
Produces a listing of the parsed code after preprocessing and parse transforms, in the file \fI<File>\&.P\fR\&. No object file is produced\&. 
.TP 4
.B
\fI\&'E\&'\fR:
Produces a listing of the code after all source code transformations have been performed, in the file \fI<File>\&.E\fR\&. No object file is produced\&. 
.TP 4
.B
\fI\&'S\&'\fR:
Produces a listing of the assembler code in the file \fI<File>\&.S\fR\&. No object file is produced\&. 
.TP 4
.B
\fIreport_errors/report_warnings\fR:
Causes errors/warnings to be printed as they occur\&. 
.TP 4
.B
\fIreport\fR:
This is a short form for both \fIreport_errors\fR and \fIreport_warnings\fR\&. 
.TP 4
.B
\fIreturn_errors\fR:
If this flag is set, then \fI{error, ErrorList, WarningList}\fR is returned when there are errors\&. 
.TP 4
.B
\fIreturn_warnings\fR:
If this flag is set, then an extra field containing \fIWarningList\fR is added to the tuples returned on success\&. 
.TP 4
.B
\fIreturn\fR:
This is a short form for both \fIreturn_errors\fR and \fIreturn_warnings\fR\&. 
.TP 4
.B
\fIverbose\fR:
Causes more verbose information from the compiler describing what it is doing\&. 
.TP 4
.B
\fI{outdir, Dir}\fR:
Sets a new directory for the object code\&. The current directory is used for output, except when a directory has been specified with this option\&. 
.TP 4
.B
\fIexport_all\fR:
Causes all functions in the module to be exported\&. 
.TP 4
.B
\fI{i, Dir}\fR:
Add \fIDir\fR to the list of directories to be searched when including a file\&. 
.TP 4
.B
\fI{d, Macro}\fR:
.TP 4
.B
\fI{d, Macro, Value}\fR:
Defines a macro \fIMacro\fR to have the value \fIValue\fR\&. The default is \fItrue\fR)\&. 
.TP 4
.B
\fI{parse_transform, Module}\fR:
Causes the parse transformation function \fIModule:parse_transform/2\fR to be applied to the parsed code before the code is checked for errors\&. 
.TP 4
.B
\fIasm\fR:
The input file is expected to be assembler code (default file suffix "\&.S")\&. Note that the format of assembler files is not documented, and may change between releases - this option is primarily for internal debugging use\&. 
.RE
.LP
Note that all the options except the include path can also be given in the file with a \fI-compile([Option, \&.\&.\&.])\fR\&. attribute\&. 
.LP
For debugging of the compiler, or for pure curiosity, the intermediate code generated by each compiler pass can be inspected\&. A complete list of the options to produce list files can be printed by typing \fIcompile:options()\fR at the Erlang shell prompt\&. The options will be printed in order that the passes are executed\&. If more than one listing option is used, the one representing the earliest pass takes effect\&. 
.LP
\fIUnrecognized options are ignored\&.\fR
.LP
Both \fIWarningList\fR and \fIErrorList\fR have the following format: 

.nf
[{FileName,[ErrorInfo]}]\&.
.fi
.LP
\fIErrorInfo\fR is described below\&. The file name has been included here as the compiler uses the Erlang pre-processor \fIepp\fR, which allows the code to be included in other files\&. For this reason, it is important to know to \fIwhich\fR file an error or warning line number refers\&. 
.RE
.LP
.B
forms(Forms)
.br
.RS
.LP
Is the same as \fIforms(File, [verbose, report_errors, report_warnings])\fR\&. 
.RE
.LP
.B
forms(Forms, Options) -> CompRet
.br
.RS
.TP
Types
Forms = [Form]
.br
CompRet = ModRet | BinRet | ErrRet
.br
ModRet = {ok, ModuleName} | {ok, ModuleName, Warnings}
.br
BinRet = {ok, ModuleName, Binary} | {ok, ModuleName, Binary, Warnings}
.br
ErrRet = error | {error, Errors, Warnings}
.br
.RE
.RS
.LP
Analogous to \fIfile/1\fR, but takes a list of forms (in the Erlang abstract format representation) as first argument\&. The option \fIbinary\fR is implicit; i\&.e\&., no object code file is produced\&. If the options indicate that a listing file should be produced (e\&.g\&., \&'E\&'), the module name is taken as the file name\&. 
.RE
.LP
.B
format_error(ErrorDescriptor) -> string()
.br
.RS
.TP
Types
ErrorDescriptor = errordesc()
.br
.RE
.RS
.LP
Uses an \fIErrorDescriptor\fR and returns a string which describes the error\&. This function is usually called implicitly when an \fIErrorInfo\fR structure is processed\&. See below\&. 
.RE
.SH Default compiler options
.LP
The (host operating system) environment variable \fIERL_COMPILER_OPTIONS\fR can be used to give default compiler options\&. Its value must be a valid Erlang term\&. If the value is a list, it will be used as is\&. If it is not a list, it will be put into a list\&. The list will be appended to any options given to \fIfile/2\fR or \fIforms/2\fR\&. 
.SH Inlining
.LP
The compiler can now do function inlining within an Erlang module\&. Inlining means that a call to a function is replaced with the function body with the arguments replaced with the actual values\&. The semantics are preserved, except if exceptions are generated in the inlined code\&. Exceptions will be reported as occurring in the function the body was inlined into\&. Also, \fIfunction_clause\fR exceptions will be converted to similar \fIcase_clause\fR exceptions\&. 
.LP
When a function is inlined, the original function may be kept as a separate function as well, because there might still be calls to it\&. Therefore, inlining almost always increases code size\&. 
.LP
Inlining does not necessarily improve running time, especially if large functions are inlined\&. The increased code size may cause the code to run the slower (because of worse CPU cache performance)\&. Also, inlining may increase Beam stack usage which will probably be detrimental to performance for recursive functions\&. 
.LP
Inlining is never default; it must be explicitly enabled with a compiler option or a \&'\fI-compile()\fR\&' attribute in the source module\&. 
.LP
There are two distinct ways to enable inlining (which may be combined)\&. 
.LP
The first way is to explicitly list the functions to be inlined at all call places\&. The syntax is \fI{inline, [{F, A}, \&.\&.\&.]}\fR, where \fIF\fR is a function name and \fIA\fR its arity\&. 
.LP
Example from an Erlang module:

.nf
-compile({inline,[{mkop,3},{mkop,2},{line,1}]})\&.
.fi
.LP
Here the functions \fImkop/3\fR, \fImkop/2\fR, and \fIline/1\fR will be inlined every time they are used\&. 
.LP
This type of unconditional inlining is useful for small, simple functions as an alternative to macros\&. The functions mentioned in the example are defined like this:

.nf
mkop(L, {Op,Pos}, R) -> {op,Pos,Op,L,R}\&.
mkop({Op,Pos}, A) -> {op,Pos,Op,A}\&.
line(Tup) -> element(2, Tup)\&.
.fi
.LP
There are other benefits when using explicit inlining instead of macros\&. The arguments will only be evaluated once, which can be critical if they contain side effects or are large computations, and it also makes it easy to have local variables, which is difficult with macros\&. 
.LP
The other type of inlining is conditional inlining\&. The compiler will search for candiates suitable for inlining\&. It does this by calculating a weight for each function\&. The weight is roughly proportional to the size of the function\&. Given the weight for each function, the compiler will only inline functions lighter than calling function and below a given threshold value\&. 
.LP
To enable conditional inlining, you can use the \&'\fIinline\fR\&' option, which sets a threshold value of 10, or you can explicitly give a threshold value like this: \fI{inline, Threshold}\fR\&. 
.LP
Example:

.nf
-compile({inline,1000})\&.
.fi
.LP
A threshold of 1000 would inline most functions (except for extremly large), provided that the functions are lighter than the functions they are inlined into\&. It is not clear that this is a good idea\&. It all depends on your code\&. 
.SS Warning:
.LP
Conditional inlining should be used with caution, since it may actually increase the execution time and make debugging harder\&. You should only use it for modules that are known to be bottle-necks and measure execution times with and without inlining\&. 

.SH Parse Transformations
.LP
Parse transformations are used when a programmer wants to use Erlang syntax but with different semantics\&. The original Erlang code is then transformed into other Erlang code\&. 
.SH Error Information
.LP
The \fIErrorInfo\fR mentioned above is the standard \fIErrorInfo\fR structure which is returned from all IO modules\&. It has the following format 

.nf
    {ErrorLine, Module, ErrorDescriptor}
.fi
.LP
A string describing the error is obtained with the following call: 

.nf
apply(Module, format_error, ErrorDescriptor)
.fi
.SH See Also
.LP
epp, erl_id_trans, erl_lint 
.SH AUTHOR
.nf
Bjorn Gustavsson - support@erlang.ericsson.se
.fi
