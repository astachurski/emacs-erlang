.TH eva 3 "eva  2.0.2.1" "Ericsson Utvecklings AB" "ERLANG MODULE DEFINITION"
.SH MODULE
eva  \- Client API for the Event and Alarm handling Functionality in the EVA Application
.SH DESCRIPTION
.LP
This module contains functions for the client API to the Event and Alarm handling application EVA\&. EVA is a distributed global application, which means that clients can access the EVA functionality from any node\&. There is a globally registered server called \fIeva_server\fR to which all requests are sent\&. The client functions for sending and clearing events and alarms exist in two variants; one asynchronous and one synchronous\&. The decision to use one or the other depends on how secure the delivery of events should be\&. If the asynchronous variant is used, the message may be lost if the node where the \fIeva_server\fR crashes after the message is sent, but before it is correctly received\&. The synchronous variant fails if it does not get an acknowledgment back from the server\&. In this case, it is up to the client application to decide what to do\&. It may, for example, wait a few seconds for another node to takeover the EVA application, and then try again\&. 
.LP
An \fIevent\fR is a notification sent from the  NE to a management application\&. An event is uniquely identified by its name\&. A special form of an event is an \fIalarm\fR\&. An alarm represents a fault in the system that needs to be reported to the manager\&. An example of an alarm could be \fIequipment_on_fire\fR\&. When an alarm is sent, it becomes active and is stored in an \fIactive alarm list\fR\&. When the application from which the alarm was sent notices that the fault that caused the alarm is not valid anymore, it \fIclears\fR the alarm\&. When an alarm is cleared, the alarm is deleted from the active alarm list, and an \fIclear_alarm\fR event is generated by EVA\&. Each fault may give rise to several alarms, maybe with different severities\&. There can, however, only be one active alarm for each fault at any one time\&. For example, associated with disk space usage may be two alarms, \fIdisk_80_percent_filled\fR and \fIdisk_90_percent_filled\fR\&. These two alarms represents the same fault, but only one of them can be active at the same time\&. An active alarm is identified by its \fIfault_id\fR\&. In contrast to alarms, ordinary events do not represent a fault, and they are not stored as the alarms in the active alarm list\&. 
.LP
The basic EVA server is a global server to which all events and alarms are sent\&. The server updates its tables, the active alarm list for example, and sends the event or alarm to the \fIalarm_handler\fR process that runs on the same node as the global server\&. \fIalarm_handler\fR is a \fIgen_event\fR process defined in SASL\&. 
.LP
EVA stores the definitions of events and alarms in the Mnesia tables \fIeventTable\fR and \fIalarmTable\fR respectively\&. As an alarm is a special form of an event, each alarm is present in both of these tables\&. The active alarm list is stored in the Mnesia table \fIalarm\fR\&. The records for all these tables are defined in the header file \fIeva\&.hrl\fR, available in the \fIinclude\fR directory in the distribution\&. 
.LP
The EVA application provides functionality to send and to log events and alarms\&. The logs can be examined by a manager at a later time\&. 
.LP
Before a client can send any events or alarms, the name of the event must be registered in EVA\&. To register an event, a client calls \fIregister_event/2\fR\&. The parameters of this function are the name of the event and notification of whether the event should be logged by default or not\&. A manager can decide to change this value later\&. To register an alarm, a client calls \fIregister_alarm/4\fR\&. The parameters of this function are the name and logging parameters as for events, and the class and default severity of the alarm\&. 

.SH Adaptations and Subscriptions
.LP
The EVA services are management protocol independent\&. However, to provide EVA services to a manager, a management protocol is however needed\&. EVA uses \fIadaptations\fR for mapping of EVA services to specific protocols\&. Adaptations need access to the Mnesia tables used in EVA\&. 
.LP
The event definitions are stored in the Mnesia table \fIeventTable\fR, and the alarm definitions in \fIalarmTable\fR\&. They are replicated to disk and RAM on each node that may run the EVA application\&. The tables are defined as follows: 

.nf
-record(eventTable, {name, log, generated})\&.
-record(alarmTable, {name, class, severity})\&.
.fi
.LP
Each alarm is defined in both the event and alarm table, since an alarm is a special kind of event\&. \fIlog\fR is a boolean which defines whether the event should be logged or not, \fIgenerated\fR is a counter that is incremented each time this event is sent, \fIclass\fR and \fIseverity\fR are as defined in \fIregister_alarm/4\fR below\&. 
.LP
The active alarm list is stored in the Mnesia table \fIalarm\fR\&. The \fIalarm\fR record is defined as: 

.nf
-record(alarm, {index, fault_id, name, sender,
                cause, severity, time, extra})\&.
.fi
.LP
These records are defined in the file \fIinclude/eva\&.hrl\fR\&. To include this file in your code, use \fI-include_lib("eva/include/eva\&.hrl")\&.\fR\&. 
.LP
All these tables are part of the API, which means that they may be accessed and modified by any application, for example by an EVA adaptation\&. They must be accessed and modified within a transaction\&. 
.LP
When an event or alarm is generated by an application, it is sent to the global eva server, which updates the Mnesia tables, and constructs a record that it sends to the local \fIalarm_handler\fR process in the SASL application\&. \fIalarm_handler\fR is a \fIgen_event\fR manager process, which means that eva server uses \fIgen_event:notify\fR to send the event or alarm record\&. An application which needs to subscribe to certain events, should write a \fIgen_event\fR handler module and install it in the \fIalarm_handler\fR\&. EVA adaptations should do this as well\&. The eva server sends the following gen_event notifications to \fIalarm_handler\fR: 
.RS 2
.TP 4
.B
\fI{register_alarm, Name}\fR:
Sent when an alarm has been registered\&. 
.TP 4
.B
\fI{register_event, Name}\fR:
Sent when an event has been registered\&. 
.TP 4
.B
\fI{send_alarm, #alarm}\fR:
Sent when an alarm is to be sent\&. The eva server sends this notification after the Mnesia tables have been updated\&. An adaptation should translate the \fI#alarm\fR into a format suitable for the protocol that the adaptation implements\&. 
.TP 4
.B
\fI{send_event, #event}\fR:
Sent when an event is to be sent\&. The eva server sends this notification after the Mnesia tables have been updated\&. An adaptation should translate the \fI#event\fR into a format suitable for the protocol the adaptation implements\&. 
.TP 4
.B
\fI{unregister_alarm, Name}\fR:
Sent when an alarm has been unregistered\&. 
.TP 4
.B
\fI{unregister_event, Name}\fR:
Sent when an event has been unregistered\&. 
.RE
.LP
When an alarm is cleared, EVA generates an event called \fIclear_alarm\fR, where \fI#event\&.sender\fR is the index in the table \fIalarm\fR\&. For example, if an application calls \fIeva:clear_alarm(Fault)\fR and the fault was stored with index 6 in the active alarm list, the following \fI#event\fR is generated: \fI#event{name = clear_alarm, sender = 6}\fR\&. 
.LP
The \fIclear_alarm\fR event is generated using \fIgen_event:sync_notify\fR, which means that all adaptations and subscribers are given a chance to take care of this event, before the alarm is deleted from the active alarm list\&. 
.SH EXPORTS
.LP
.B
aclear_alarm(FaultId)
.br
.B
clear_alarm(FaultId)
.br
.B
clear_alarm(FaultId, Time) -> ok
.br
.RS
.TP
Types
FaultId = fault_id()
.br
Time = integer() > 0 | infinity
.br
.RE
.RS
.LP
These functions are used to clear an active alarm\&. The \fIFaultId\fR is a term the uniquely identifies the fault\&. For example, the function \fIget_fault_id/0\fR can be used to generate a unique id\&. 
.LP
\fIaclear_alarm/1\fR is an asynchronous function which just sends the clear alarm request to the global eva server\&. \fIclear_alarm/1, 2\fR are synchronous functions that wait \fITime\fR ms for an answer\&. If \fITime\fR is not given, it defaults to 10000 ms\&. 
.LP
If the server does not respond within the specified time, the function exits with reason \fI{timeout, _}\fR\&. 
.RE
.LP
.B
get_alarm_status() -> [{Severity, boolean()}]
.br
.RS
.TP
Types
Severity = severity()
.br
.RE
.RS
.LP
For each alarm severity, it returns information on whether there is any active alarm for that severity or not\&. 
.RE
.LP
.B
get_alarms(Item) -> [#alarm]
.br
.RS
.TP
Types
Item = {name, Name} | {sender, Sender}
.br
Name = atom()
.br
Sender = term()
.br
.RE
.RS
.LP
Returns all active alarms which match \fIItem\fR\&. This function can be used by a client to check if it has any active alarms defined when it starts\&. For each such alarm, it must be prepared to clear it\&. A client may, for example, at start-up perform a "self-test" to see which alarms should be active, and compare then this with what this function returns, and clear or send missing alarms\&. 
.RE
.LP
.B
get_fault_id() -> fault_id()
.br
.RS
.LP
This function can be called before a client sends an alarm to obtain a globally unique fault identity that can be used in subsequent calls to \fIsend_alarm\fR and \fIclear_alarm\fR\&. 
.LP
This function does not communicate with the \fIeva_server\fR, it just constructs a unique reference and is therefore fast\&. 
.RE
.LP
.B
get_no_alarms() -> integer()
.br
.RS
.LP
Returns the number of active alarms in the system\&. 
.RE
.LP
.B
register_alarm(Name, Log, Class, Severity) -> boolean()
.br
.RS
.TP
Types
Name = atom()
.br
Log = boolean()
.br
Class = class()
.br
Severity = severity()
.br
class() = unknown | communications | qos | processing | equipment | environmental
.br
severity() = indeterminate | critical | major | minor| warning
.br
.RE
.RS
.LP
Registers an alarm within EVA\&. An alarm must be registered before it is sent the first time\&. The registration information is stored persistently, so this function can be called just once\&. However, if EVA detects that the alarm is already registered, it discards the registration and returns \fIfalse\fR\&. Otherwise, it returns \fItrue\fR\&. 
.LP
The \fILog\fR parameter defines if the alarm should be logged by default or not\&. 
.LP
The \fIClass\fR and \fISeverity\fR parameters are originally defined in X\&.733, ITU Alarm Reporting Function\&. 
.RE
.LP
.B
register_event(Name, Log) -> boolean()
.br
.RS
.TP
Types
Name = atom()
.br
Log = boolean()
.br
.RE
.RS
.LP
Registers an event within EVA\&. An event must be registered before it is sent the first time\&. The registration information is stored persistently, so this function can be called just once\&. However, if EVA detects that the event is already registered, it discards the registration and returns \fIfalse\fR\&. Otherwise, it returns \fItrue\fR\&. 
.LP
The \fILog\fR parameter defines if the event should be logged by default or not\&. 
.RE
.LP
.B
asend_alarm(Name, FaultId, Sender, Cause, Extra)
.br
.B
send_alarm(Name, FaultId, Sender, Cause, Extra)
.br
.B
send_alarm(Name, FaultId, Sender, Cause, Extra, Time) -> ok | {error, Reason}
.br
.RS
.TP
Types
Name = atom()
.br
FaultId = fault_id()
.br
Sender = term()
.br
Cause = term()
.br
Extra = term()
.br
Time = integer() > 0 | infinity
.br
Reason = {no_such_alarm, Name} | {aborted, Name, R}
.br
.RE
.RS
.LP
These functions are used to send an alarm and make it active (stored in the active alarm list)\&. 
.LP
\fIName\fR is the name of the alarm\&. The alarm must be registered before this function is called\&. 
.LP
\fIFaultId\fR is a term the uniquely identifies the fault\&. For example, the function \fIget_fault_id/0\fR can be used to generate a unique id\&. 
.LP
\fISender\fR is the object that generated the alarm\&. It could, for example, be a tuple \fI{board, 7}\fR or a registered name\&. This object should be fairly constant - not a Pid - so that it is possible to trace the sending object at a later time\&. 
.LP
\fICause\fR is the cause of the alarm\&. It is recommended not to use strings as cause, to make it easier to match upon for other programs\&. For example a management application may want to translate the cause into another language\&. 
.LP
\fIExtra\fR is any extra information which describes the alarm\&. 
.LP
\fIasend_alarm/5\fR is an asynchronous function which just sends the alarm request to the global eva server\&. \fIsend_alarm/5, 6\fR are synchronous functions that wait \fITime\fR ms for an answer\&. If \fITime\fR is not given, it defaults to 10000 ms\&. 
.LP
If the server does not respond within the specified time, the function exits with reason \fI{timeout, _}\fR\&. 
.RE
.LP
.B
asend_event(Name, Sender, Extra)
.br
.B
send_event(Name, Sender, Extra)
.br
.B
send_event(Name, Sender, Extra, Time) -> ok | {error, Reason}
.br
.RS
.TP
Types
Name = atom()
.br
Sender = term()
.br
Extra = term()
.br
Time = integer() > 0 | infinity
.br
Reason = {no_such_event, Name} | {aborted, Name, R}
.br
.RE
.RS
.LP
These functions are used to send an event to the eva server\&. 
.LP
\fIName\fR is the name of the event\&. The event must be registered before this function is called\&. 
.LP
\fISender\fR is the object that generated the event\&. It could, for example, be a tuple \fI{board, 7}\fR or a registered name\&. This object should be fairly constant - not a Pid - so that it is possible to trace the sending object at a later time\&. 
.LP
\fIExtra\fR is any extra information which describes the event\&. 
.LP
\fIasend_event/3\fR is an asynchronous function, that just sends the event request to the global eva server\&. \fIsend_event/3, 4\fR are synchronous functions that waits \fITime\fR ms for an answer\&. If \fITime\fR is not given, it defaults to 10000 ms\&. 
.LP
If the server does not respond within the specified time, the function exits with reason \fI{timeout, _}\fR\&. 
.RE
.LP
.B
unregister_alarm(Name) -> void()
.br
.RS
.TP
Types
Name = atom()
.br
.RE
.RS
.LP
Unregisters an alarm within EVA\&. This function should only be used when an alarm definition should be removed, due to a new release of the system, for example\&. 
.RE
.LP
.B
unregister_event(Name) -> void()
.br
.RS
.TP
Types
Name = atom()
.br
.RE
.RS
.LP
Unregisters an event within EVA\&. This function should only be used when an event definition should be removed, due to a new release of the system, for example\&. 
.RE
.SH Access functions for the Active Alarm List
.LP
The active alarm list is stored in the Mnesia table \fIalarm\fR\&. This table is indexed by an integer \fIalarmIndex\fR\&. This integer is used to get the table ordered, with the latest sent alarm after the previous\&. Currently ordered Mnesia tables cannot be traversed in a convenient way and for this reason this module provides two functions to handle the traversal\&. These functions will be removed if ordered tables are implemented in Mnesia\&. 
.SH EXPORTS
.LP
.B
alarm_first() -> {ok, Index} | \&'$end_of_table\&'
.br
.RS
.TP
Types
Index = integer()
.br
.RE
.RS
.LP
Returns the index of the first element in the alarm table\&. This is a temporary function which will be removed if ordered tables are implemented in Mnesia\&. 
.RE
.LP
.B
alarm_next(Index) -> {ok, NextIndex} | \&'$end_of_table\&'
.br
.RS
.TP
Types
Index = NextIndex = integer()
.br
.RE
.RS
.LP
Returns the next index after \fIIndex\fR in the alarm table\&. This is a temporary function which will be removed if ordered tables are implemented in Mnesia\&. 
.RE
.SH SEE ALSO
.LP
alarm_handler(3), gen_event(3), mnesia(3) 
.SH AUTHOR
.nf
Martin Bjorklund - support@erlang.ericsson.se
.fi
