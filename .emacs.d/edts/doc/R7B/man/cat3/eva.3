


eva(3)              ERLANG MODULE DEFINITION               eva(3)



MODULE
     eva  - Client API for the Event  and  Alarm  handling  Func-
     tionality in the EVA Application

DESCRIPTION
     This module contains functions for the  client  API  to  the
     Event  and  Alarm handling application EVA. EVA is a distri-
     buted global  application,  which  means  that  clients  can
     access  the EVA functionality from any node. There is a glo-
     bally registered  server  called  _e_v_a__s_e_r_v_e_r  to  which  all
     requests  are  sent.  The  client  functions for sending and
     clearing events and alarms exist in two variants; one  asyn-
     chronous and one synchronous. The decision to use one or the
     other depends on how secure the delivery  of  events  should
     be.  If the asynchronous variant is used, the message may be
     lost if the node where the _e_v_a__s_e_r_v_e_r crashes after the mes-
     sage  is sent, but before it is correctly received. The syn-
     chronous variant fails if it does not get an  acknowledgment
     back  from  the server. In this case, it is up to the client
     application to decide what to do. It may, for example,  wait
     a  few seconds for another node to takeover the EVA applica-
     tion, and then try again.

     An _e_v_e_n_t is a notification sent from the  NE to a management
     application.  An event is uniquely identified by its name. A
     special form of an event is an _a_l_a_r_m. An alarm represents  a
     fault  in  the  system  that  needs  to  be  reported to the
     manager. An example of an alarm could be  _e_q_u_i_p_m_e_n_t__o_n__f_i_r_e.
     When an alarm is sent, it becomes active and is stored in an
     _a_c_t_i_v_e _a_l_a_r_m _l_i_s_t. When the application from which the alarm
     was sent notices that the fault that caused the alarm is not
     valid anymore,  it  _c_l_e_a_r_s  the  alarm.  When  an  alarm  is
     cleared,  the  alarm  is deleted from the active alarm list,
     and an _c_l_e_a_r__a_l_a_r_m event is generated by EVA. Each fault may
     give  rise  to  several alarms, maybe with different severi-
     ties. There can, however, only be one active alarm for  each
     fault  at  any  one  time. For example, associated with disk
     space usage may be two  alarms,  _d_i_s_k__8_0__p_e_r_c_e_n_t__f_i_l_l_e_d  and
     _d_i_s_k__9_0__p_e_r_c_e_n_t__f_i_l_l_e_d. These two alarms represents the same
     fault, but only one of them can be active at the same  time.
     An  active  alarm is identified by its _f_a_u_l_t__i_d. In contrast
     to alarms, ordinary events do not  represent  a  fault,  and
     they are not stored as the alarms in the active alarm list.

     The basic EVA server is a global server to which all  events
     and  alarms  are  sent.  The  server updates its tables, the
     active alarm list for example, and sends the event or  alarm
     to  the  _a_l_a_r_m__h_a_n_d_l_e_r process that runs on the same node as
     the global server.  _a_l_a_r_m__h_a_n_d_l_e_r  is  a  _g_e_n__e_v_e_n_t  process
     defined in SASL.





Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   1






eva(3)              ERLANG MODULE DEFINITION               eva(3)



     EVA stores the definitions  of  events  and  alarms  in  the
     Mnesia  tables _e_v_e_n_t_T_a_b_l_e and _a_l_a_r_m_T_a_b_l_e respectively. As an
     alarm is a special form of an event, each alarm  is  present
     in  both of these tables. The active alarm list is stored in
     the Mnesia table _a_l_a_r_m. The records for all these tables are
     defined in the header file _e_v_a._h_r_l, available in the _i_n_c_l_u_d_e
     directory in the distribution.

     The EVA application provides functionality to  send  and  to
     log events and alarms. The logs can be examined by a manager
     at a later time.

     Before a client can send any events or alarms, the  name  of
     the event must be registered in EVA. To register an event, a
     client calls _r_e_g_i_s_t_e_r__e_v_e_n_t/_2. The parameters of this  func-
     tion  are  the name of the event and notification of whether
     the event should be logged by default or not. A manager  can
     decide  to  change this value later. To register an alarm, a
     client calls _r_e_g_i_s_t_e_r__a_l_a_r_m/_4. The parameters of this  func-
     tion  are the name and logging parameters as for events, and
     the class and default severity of the alarm.


Adaptations and Subscriptions
     The EVA services are management protocol  independent.  How-
     ever,  to  provide  EVA  services to a manager, a management
     protocol is however needed. EVA uses _a_d_a_p_t_a_t_i_o_n_s for mapping
     of  EVA  services  to  specific  protocols. Adaptations need
     access to the Mnesia tables used in EVA.

     The event definitions are stored in the Mnesia table _e_v_e_n_t_T_-
     _a_b_l_e,  and  the  alarm  definitions  in _a_l_a_r_m_T_a_b_l_e. They are
     replicated to disk and RAM on each node that may run the EVA
     application. The tables are defined as follows:

     -record(eventTable, {name, log, generated}).
     -record(alarmTable, {name, class, severity}).

     Each alarm is defined in both the  event  and  alarm  table,
     since  an alarm is a special kind of event. _l_o_g is a boolean
     which defines whether the event should  be  logged  or  not,
     _g_e_n_e_r_a_t_e_d  is  a  counter that is incremented each time this
     event  is  sent,  _c_l_a_s_s  and  _s_e_v_e_r_i_t_y  are  as  defined  in
     _r_e_g_i_s_t_e_r__a_l_a_r_m/_4 below.

     The active alarm list is stored in the Mnesia  table  _a_l_a_r_m.
     The _a_l_a_r_m record is defined as:

     -record(alarm, {index, fault_id, name, sender,
                     cause, severity, time, extra}).





Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   2






eva(3)              ERLANG MODULE DEFINITION               eva(3)



     These records are defined in the  file  _i_n_c_l_u_d_e/_e_v_a._h_r_l.  To
     include      this     file     in     your     code,     use
     -_i_n_c_l_u_d_e__l_i_b("_e_v_a/_i_n_c_l_u_d_e/_e_v_a._h_r_l")..

     All these tables are part of the API, which means that  they
     may be accessed and modified by any application, for example
     by an EVA adaptation. They must  be  accessed  and  modified
     within a transaction.

     When an event or alarm is generated by an application, it is
     sent  to  the  global  eva  server, which updates the Mnesia
     tables, and constructs a record that it sends to  the  local
     _a_l_a_r_m__h_a_n_d_l_e_r process in the SASL application. _a_l_a_r_m__h_a_n_d_l_e_r
     is a _g_e_n__e_v_e_n_t manager process, which means that eva  server
     uses  _g_e_n__e_v_e_n_t:_n_o_t_i_f_y to send the event or alarm record. An
     application which needs  to  subscribe  to  certain  events,
     should  write  a  _g_e_n__e_v_e_n_t handler module and install it in
     the _a_l_a_r_m__h_a_n_d_l_e_r. EVA adaptations should do this  as  well.
     The  eva  server sends the following gen_event notifications
     to _a_l_a_r_m__h_a_n_d_l_e_r:

       {_r_e_g_i_s_t_e_r__a_l_a_r_m, _N_a_m_e}:
           Sent when an alarm has been registered.

       {_r_e_g_i_s_t_e_r__e_v_e_n_t, _N_a_m_e}:
           Sent when an event has been registered.

       {_s_e_n_d__a_l_a_r_m, #_a_l_a_r_m}:
           Sent when an alarm is to be sent. The eva server sends
           this  notification  after  the Mnesia tables have been
           updated. An adaptation  should  translate  the  #_a_l_a_r_m
           into a format suitable for the protocol that the adap-
           tation implements.

       {_s_e_n_d__e_v_e_n_t, #_e_v_e_n_t}:
           Sent when an event is to be sent. The eva server sends
           this  notification  after  the Mnesia tables have been
           updated. An adaptation  should  translate  the  #_e_v_e_n_t
           into a format suitable for the protocol the adaptation
           implements.

       {_u_n_r_e_g_i_s_t_e_r__a_l_a_r_m, _N_a_m_e}:
           Sent when an alarm has been unregistered.

       {_u_n_r_e_g_i_s_t_e_r__e_v_e_n_t, _N_a_m_e}:
           Sent when an event has been unregistered.

     When an alarm is cleared,  EVA  generates  an  event  called
     _c_l_e_a_r__a_l_a_r_m,  where  #_e_v_e_n_t._s_e_n_d_e_r is the index in the table
     _a_l_a_r_m.   For    example,    if    an    application    calls
     _e_v_a:_c_l_e_a_r__a_l_a_r_m(_F_a_u_l_t) and the fault was stored with index 6
     in the active alarm list, the following #_e_v_e_n_t is generated:



Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   3






eva(3)              ERLANG MODULE DEFINITION               eva(3)



     #_e_v_e_n_t{_n_a_m_e = _c_l_e_a_r__a_l_a_r_m, _s_e_n_d_e_r = _6}.

     The     _c_l_e_a_r__a_l_a_r_m     event     is     generated     using
     _g_e_n__e_v_e_n_t:_s_y_n_c__n_o_t_i_f_y,  which means that all adaptations and
     subscribers are given a chance to take care of  this  event,
     before the alarm is deleted from the active alarm list.

EXPORTS
     aclear_alarm(FaultId)
     clear_alarm(FaultId)
     clear_alarm(FaultId, Time) -> ok

          Types
               FaultId = fault_id()
               Time = integer() > 0 | infinity

          These functions are used to clear an active alarm.  The
          _F_a_u_l_t_I_d  is  a  term the uniquely identifies the fault.
          For example, the function _g_e_t__f_a_u_l_t__i_d/_0 can be used to
          generate a unique id.

          _a_c_l_e_a_r__a_l_a_r_m/_1 is an asynchronous function  which  just
          sends the clear alarm request to the global eva server.
          _c_l_e_a_r__a_l_a_r_m/_1, _2 are synchronous  functions  that  wait
          _T_i_m_e  ms  for  an  answer.  If  _T_i_m_e  is  not given, it
          defaults to 10000 ms.

          If the server does not  respond  within  the  specified
          time, the function exits with reason {_t_i_m_e_o_u_t, _}.

     get_alarm_status() -> [{Severity, boolean()}]

          Types
               Severity = severity()

          For each alarm  severity,  it  returns  information  on
          whether  there is any active alarm for that severity or
          not.

     get_alarms(Item) -> [#alarm]

          Types
               Item = {name, Name} | {sender, Sender}
               Name = atom()
               Sender = term()

          Returns all active alarms which match _I_t_e_m. This  func-
          tion  can  be  used  by a client to check if it has any
          active alarms defined when it  starts.  For  each  such
          alarm,  it  must be prepared to clear it. A client may,
          for example, at start-up perform a "self-test"  to  see
          which  alarms  should  be active, and compare then this



Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   4






eva(3)              ERLANG MODULE DEFINITION               eva(3)



          with what this function  returns,  and  clear  or  send
          missing alarms.

     get_fault_id() -> fault_id()

          This function can be called before a  client  sends  an
          alarm  to  obtain a globally unique fault identity that
          can be used  in  subsequent  calls  to  _s_e_n_d__a_l_a_r_m  and
          _c_l_e_a_r__a_l_a_r_m.

          This function does not communicate with the _e_v_a__s_e_r_v_e_r,
          it  just constructs a unique reference and is therefore
          fast.

     get_no_alarms() -> integer()

          Returns the number of active alarms in the system.

     register_alarm(Name, Log, Class, Severity) -> boolean()

          Types
               Name = atom()
               Log = boolean()
               Class = class()
               Severity = severity()
               class() = unknown | communications |  qos  |  pro-
               cessing | equipment | environmental
               severity() = indeterminate | critical  |  major  |
               minor| warning

          Registers  an  alarm  within  EVA.  An  alarm  must  be
          registered before it is sent the first time. The regis-
          tration information is  stored  persistently,  so  this
          function  can  be  called  just  once.  However, if EVA
          detects that the alarm is already registered,  it  dis-
          cards the registration and returns _f_a_l_s_e. Otherwise, it
          returns _t_r_u_e.

          The _L_o_g parameter defines if the alarm should be logged
          by default or not.

          The  _C_l_a_s_s  and  _S_e_v_e_r_i_t_y  parameters  are   originally
          defined in X.733, ITU Alarm Reporting Function.

     register_event(Name, Log) -> boolean()

          Types
               Name = atom()
               Log = boolean()

          Registers  an  event  within  EVA.  An  event  must  be
          registered  before  it  is  sent  the  first  time. The



Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   5






eva(3)              ERLANG MODULE DEFINITION               eva(3)



          registration information  is  stored  persistently,  so
          this  function can be called just once. However, if EVA
          detects that the event is already registered,  it  dis-
          cards the registration and returns _f_a_l_s_e. Otherwise, it
          returns _t_r_u_e.

          The _L_o_g parameter defines if the event should be logged
          by default or not.

     asend_alarm(Name, FaultId, Sender, Cause, Extra)
     send_alarm(Name, FaultId, Sender, Cause, Extra)
     send_alarm(Name, FaultId, Sender, Cause, Extra, Time) ->  ok
     | {error, Reason}

          Types
               Name = atom()
               FaultId = fault_id()
               Sender = term()
               Cause = term()
               Extra = term()
               Time = integer() > 0 | infinity
               Reason = {no_such_alarm, Name} |  {aborted,  Name,
               R}

          These functions are used to send an alarm and  make  it
          active (stored in the active alarm list).

          _N_a_m_e is the name  of  the  alarm.  The  alarm  must  be
          registered before this function is called.

          _F_a_u_l_t_I_d is a term the uniquely  identifies  the  fault.
          For example, the function _g_e_t__f_a_u_l_t__i_d/_0 can be used to
          generate a unique id.

          _S_e_n_d_e_r is the  object  that  generated  the  alarm.  It
          could,  for  example,  be  a  tuple  {_b_o_a_r_d,  _7}  or  a
          registered name. This object should be fairly  constant
          - not a Pid - so that it is possible to trace the send-
          ing object at a later time.

          _C_a_u_s_e is the cause of the alarm. It is recommended  not
          to  use  strings  as  cause, to make it easier to match
          upon for  other  programs.  For  example  a  management
          application  may  want  to  translate  the  cause  into
          another language.

          _E_x_t_r_a is any  extra  information  which  describes  the
          alarm.

          _a_s_e_n_d__a_l_a_r_m/_5 is an asynchronous  function  which  just
          sends  the  alarm  request  to  the  global eva server.
          _s_e_n_d__a_l_a_r_m/_5, _6 are  synchronous  functions  that  wait



Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   6






eva(3)              ERLANG MODULE DEFINITION               eva(3)



          _T_i_m_e  ms  for  an  answer.  If  _T_i_m_e  is  not given, it
          defaults to 10000 ms.

          If the server does not  respond  within  the  specified
          time, the function exits with reason {_t_i_m_e_o_u_t, _}.

     asend_event(Name, Sender, Extra)
     send_event(Name, Sender, Extra)
     send_event(Name, Sender, Extra, Time) -> ok |  {error,  Rea-
     son}

          Types
               Name = atom()
               Sender = term()
               Extra = term()
               Time = integer() > 0 | infinity
               Reason = {no_such_event, Name} |  {aborted,  Name,
               R}

          These functions are used to send an event  to  the  eva
          server.

          _N_a_m_e is the name  of  the  event.  The  event  must  be
          registered before this function is called.

          _S_e_n_d_e_r is the  object  that  generated  the  event.  It
          could,  for  example,  be  a  tuple  {_b_o_a_r_d,  _7}  or  a
          registered name. This object should be fairly  constant
          - not a Pid - so that it is possible to trace the send-
          ing object at a later time.

          _E_x_t_r_a is any  extra  information  which  describes  the
          event.

          _a_s_e_n_d__e_v_e_n_t/_3 is an asynchronous  function,  that  just
          sends  the  event  request  to  the  global eva server.
          _s_e_n_d__e_v_e_n_t/_3, _4 are synchronous  functions  that  waits
          _T_i_m_e  ms  for  an  answer.  If  _T_i_m_e  is  not given, it
          defaults to 10000 ms.

          If the server does not  respond  within  the  specified
          time, the function exits with reason {_t_i_m_e_o_u_t, _}.

     unregister_alarm(Name) -> void()

          Types
               Name = atom()

          Unregisters an alarm within EVA. This  function  should
          only  be  used  when  an  alarm  definition  should  be
          removed, due to a new release of the system, for  exam-
          ple.



Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   7






eva(3)              ERLANG MODULE DEFINITION               eva(3)



     unregister_event(Name) -> void()

          Types
               Name = atom()

          Unregisters an event within EVA. This  function  should
          only  be  used  when  an  event  definition  should  be
          removed, due to a new release of the system, for  exam-
          ple.

Access functions for the Active Alarm
     The active alarm list is stored in the Mnesia  table  _a_l_a_r_m.
     This table is indexed by an integer _a_l_a_r_m_I_n_d_e_x. This integer
     is used to get the table ordered, with the latest sent alarm
     after  the  previous. Currently ordered Mnesia tables cannot
     be traversed in a convenient way and for  this  reason  this
     module provides two functions to handle the traversal. These
     functions will be removed if ordered tables are  implemented
     in Mnesia.

EXPORTS
     alarm_first() -> {ok, Index} | '$end_of_table'

          Types
               Index = integer()

          Returns the index of the first  element  in  the  alarm
          table.  This  is  a  temporary  function  which will be
          removed if ordered tables are implemented in Mnesia.

     alarm_next(Index) -> {ok, NextIndex} | '$end_of_table'

          Types
               Index = NextIndex = integer()

          Returns the next index after _I_n_d_e_x in the alarm  table.
          This  is  a temporary function which will be removed if
          ordered tables are implemented in Mnesia.

SEE ALSO
     alarm_handler(3), gen_event(3), mnesia(3)

AUTHOR
     Martin Bjorklund - support@erlang.ericsson.se











Ericsson UtvecklingsLAaBst change: eva  2.0.2.1                   8



