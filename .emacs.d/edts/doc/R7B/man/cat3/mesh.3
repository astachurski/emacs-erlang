


mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



MODULE
     mesh  - Client API for Mesh.

DESCRIPTION
     This module contains  the  client  API  to  the  Measurement
     Handler  application  Mesh.  Mesh  is  a  distributed global
     application, which means that clients can  access  the  Mesh
     functionality  from  any connected node. There is a globally
     registered server called _m_e_s_h__s_e_r_v_e_r to which  all  requests
     are    sent.    Currently    all   functions   (except   the
     _m_e_a_s_u_r_e_m_e_n_t__r_e_p_o_r_t and _m_e_a_s_u_r_e_m_e_n_t__t_e_r_m_i_n_a_t_e_d functions) are
     synchronous.  This  means that the function call fails if no
     acknowledgment is returned by the server. Should  this  hap-
     pen,  the  client  application has to decide what actions to
     take. (It may, for example, wait a few seconds  for  another
     node to take over the Mesh application, and then try again.)

     Mesh stores data about  measurement  types  and  measurement
     objects  in  the  Mnesia  tables  _m_e_s_h__t_y_p_e  and  _m_e_s_h__m_e_a_s,
     respectively. They are replicated to disk and  RAM  on  each
     node that may run the Mesh application.

     Mesh uses an EVA functionality to send and to log  generated
     events  and  alarms.  The  logs  used  can  be examined by a
     manager at a later time.
      However, the configuration and start of EVA is left to  the
     client  application  programmer,  see  section  _R_e_q_u_i_r_e_m_e_n_t_s
     below. Mesh does not supervise EVA, which essentially  means
     that the client application programmer must be aware of EVA.
     For performance reasons, it is desired that EVA runs on  the
     same  node  as  the  Measurement  Handler to reduce internal
     traffic.

     Commonly used statistical functions  may  be  found  in  the
     module _m_e_s_h__l_i_b.


Starting and Stopping Mesh
     The Mesh application is controlled through  the  _a_p_p_l_i_c_a_t_i_o_n
     module   API;   Mesh   is   started  by  the  function  call
     _a_p_p_l_i_c_a_t_i_o_n:_s_t_a_r_t(_m_e_s_h),
      and stopped by the function call
      _a_p_p_l_i_c_a_t_i_o_n:_s_t_o_p(_m_e_s_h).

Requirements
     The Mesh application requires the following applications  to
     be started:

       * SASL

       * Mnesia




Ericsson Utvecklings ALBast change: mesh  1.1.0                   1






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



       * EVA

     When starting Mnesia, a schema must be created  on  each  of
     the  nodes  where  the Mesh application will be running; see
     for example function _m_n_e_s_i_a:_c_r_e_a_t_e__s_c_h_e_m_a/_1.

     Before EVA is started, the Mnesia tables needed by the basic
     EVA  service  and  the EVA log service have to be created on
     each node where the Mesh application will  be  running;  see
     example function _e_v_a__s_u_p:_c_r_e_a_t_e__t_a_b_l_e_s__l_o_g/_1.
      Also, EVA should be started with a default log, which first
     must  be  created, see for example functions _d_i_s_k__l_o_g:_o_p_e_n/_1
     and _e_v_a:_s_t_a_r_t__l_i_n_k__l_o_g/_1.

     Before Mesh is started, the Mnesia tables needed by the Mesh
     application  have  to  be created on each of the nodes where
     the Mesh application is supposed to be will be running;  see
     example function _m_e_s_h:_c_r_e_a_t_e__t_a_b_l_e_s/_1.

Call back Module Usage
     While the Measurement Handler application takes care of com-
     mon  tasks,  user  dependent, implementation specific issues
     are handled through the _m_e_a_s_u_r_e_m_e_n_t _t_y_p_e _i_n_t_e_r_f_a_c_e  _m_o_d_u_l_e_s.
     These  modules  are  (through the measurement type registra-
     tion) associated with a specific measurement type. When Mesh
     is  ordered  to  perform certain tasks, concerning a certain
     measurement type, one or more of the functions in the  asso-
     ciated interface module may be called.

     The functions that have to  be  present  in  each  interface
     module  are  (please  also  see the section _I_n_t_e_r_f_a_c_e _M_o_d_u_l_e
     _F_u_n_c_t_i_o_n_s):

       * init/1

       * terminate/1

       * create_measurement/3

       * delete_measurement/3

       * start_measurement/3

       * stop_measurement/2

       * reset_measurement/3

     The following functions  are  optional  for  each  interface
     module:

       * set_upper_threshold/5




Ericsson Utvecklings ALBast change: mesh  1.1.0                   2






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



       * set_lower_threshold/5

       * remove_threshold/3

       * enable_threshold/3

       * disable_threshold/3

     The purpose of these latter functions  are  to  provide  the
     user   with  the  possibility  to  implement  the  threshold
     supervising functionality. For example, a measurement object
     may  just  supervise  a measurement value, reporting nothing
     until a threshold has been triggered. The measurement object
     in  question may then report directly to the manager or EVA.
     Alternatively, the measurement  object  can  send  a  normal
     measurement report to Mesh, containing the measurement value
     that triggered the threshold. In the latter case the  thres-
     hold  set  in  Mesh  will be triggered, and an alarm will be
     sent to EVA.

     The figure below describes how function calls to Mesh result
     (or  may  result)  in calls to the corresponding measurement
     type interface.

     Sometimes a function may be called more than once, for exam-
     ple,  the  _d_e_l_e_t_e__m_e_a_s_u_r_e_m_e_n_t  in  the  interface  module is
     called for each measurement object. This is not indicated in
     the  figure.  Similarly,  sometimes  a  function  may _n_o_t be
     called, depending on the context; this  is  also  not  indi-
     cated.

     Mesh                              Interface Module
     ----                              ----------------

     mesh:register_type        ---->   IM:init/1


     mesh:unregister_type      ---->   IM:delete_measurement
                                       IM:terminate


     mesh:lock_type            ---->   IM:delete_measurement


     mesh:create_measurement   ---->   IM:create_measurement


     mesh:delete_measurement   ---->   IM:delete_measurement


     mesh:revive_measurement   ---->   IM:create_measurement




Ericsson Utvecklings ALBast change: mesh  1.1.0                   3






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



     mesh_start_measurement    ---->   IM:start_measurement


     mesh:stop_measurement     ---->   IM:stop_measurement


     mesh:reset_measurement    ---->   IM:reset_measurement


     mesh:set_upper_threshold  ---->   IM:set_upper_threshold


     mesh:set_lower_threshold  ---->   IM:set_lower_threshold


     mesh:remove_threshold     ---->   IM:remove_threshold


     mesh:enable_threshold     ---->   IM:enable_threshold


     mesh:disable_threshold    ---->   IM:disable_threshold

Measurement Responsible Processes
     A Measurement Responsible  Process  (MRP)  is  one  or  more
     processes  enabling  communication  between  the measurement
     type interface and the actual  processes  implementing,  eg.
     measurement objects. Since the measurement type interface is
     stateless, it has to be supplied  with  the  identifiers  of
     these  processes,  which is done by the Measurement Handler,
     whenever it calls a measurement type interface function. The
     measurement  type  interface must ensure the correct process
     is contacted.

     Basically, there are two MRP design possibilities:

       * each measurement object is its own MRP.

       * one process, working as a server, keeps track of one  or
         more   measurement   objects,  forwarding  the  messages
         received to the correct measurement object/process.

     Whatever alternative has been chosen, an MRP has the follow-
     ing four responsibilities:

       * supervise one or more measurement objects.

       * map the measurement object  identifier  to  the  correct
         process  identifier, thereby enabling communication with
         measurement objects.

       * keep track  of  the  available  resources,  mapping  new



Ericsson Utvecklings ALBast change: mesh  1.1.0                   4






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



         measurement objects to the correct resource.

       * ensure Mesh that the user supplied supervision scheme is
         still  working.  That  is,  Mesh only supervises the MRP
         (and the node it resides on); the MRP will supervise the
         individual  measurement objects, reporting to Mesh when-
         ever one of them gets disabled (and  order  revival,  if
         that is desired).

     Should  an  MRP  terminate,  Mesh  will  assume   that   the
     corresponding  measurement objects will also terminate. This
     implies that MRPs have to be very robust, ie. they  have  to
     trap exits, even internally.

Events and Alarms
     The alarms that may be sent to EVA are:

       * _m_e_s_h_T_h_r_e_s_h_o_l_d_T_r_i_g_g_e_r_e_d. This alarm is  sent  whenever  a
         threshold  has  been  triggered. The alarm class is _q_o_s,
         and the severity _i_n_d_e_t_e_r_m_i_n_a_t_e. Other fields of interest
         in the alarm are:

         Field        Value
         -----        -----
         sender       mesh_server
         cause        {upper_threshold_triggered, {value, number()}}  |
                      {lower_threshold_triggered, {value, number()}}
         extra        {{meas, MeasId}, {id, ThreshId}}

       * _m_e_s_h_T_o_o_M_a_n_y_T_y_p_e_s. This alarm is sent by the watchdog  if
         the total number of registered measurement types exceeds
         the maximum number allowed. The alarm class is  _p_r_o_c_e_s_s_-
         _i_n_g,  and the severity _w_a_r_n_i_n_g. Other fields of interest
         in the alarm are:

         Field        Value
         -----        -----
         sender       mesh_server
         cause        {{allowed,number()},{currently,number()}}
         extra        ""

       * _m_e_s_h_T_o_o_M_a_n_y_M_e_a_s_u_r_e_m_e_n_t_s.  This  alarm  is  sent  by  the
         watchdog  if  the  total  number  of created measurement
         objects exceeds the maximum number  allowed.  The  alarm
         class  is  _p_r_o_c_e_s_s_i_n_g,  and  the severity _w_a_r_n_i_n_g. Other
         fields of interest in the alarm are:

         Field        Value
         -----        -----
         sender       mesh_server
         cause        {{allowed,number()}, {currently,number()}}
         extra        ""



Ericsson Utvecklings ALBast change: mesh  1.1.0                   5






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



       * _m_e_s_h_T_y_p_e_C_a_p_a_c_i_t_y_E_x_c_e_e_d_e_d. This alarm is  sent  when  the
         number  of  measurement  objects  belonging to a certain
         measurement type exceeds the measurement type  capacity.
         The alarm class is _p_r_o_c_e_s_s_i_n_g, and the severity _w_a_r_n_i_n_g.
         Other fields of interest in the alarm are:

         Field        Value
         -----        -----
         sender       mesh_server
         cause        {{type,TypeId}, {allowed,number()},
                       {currently,number()}}
         extra        "Capacity decreased"

     The events that may be sent to EVA are:

       * _m_e_s_h_T_y_p_e_F_a_i_l_u_r_e. This event is sent whenever a  measure-
         ment  type  MRP  has  terminated. The _e_x_t_r_a field in the
         event contains the following information:
          {_M_e_a_s_I_d, _F_a_i_l_u_r_e_R_e_a_s_o_n, _F_a_i_l_u_r_e_T_i_m_e}.

       * _m_e_s_h_M_e_a_s_u_r_e_m_e_n_t_T_e_r_m_i_n_a_t_e_d. This event is  sent  whenever
         the  Measurement  Handler has noticed that a measurement
         object has been disabled. The _e_x_t_r_a field in  the  event
         contains the following information:
          {_M_e_a_s_I_d, _T_y_p_e_I_d, _T_e_r_m_i_n_a_t_i_o_n_R_e_a_s_o_n, _T_e_r_m_i_n_a_t_i_o_n_T_i_m_e}.

       * _m_e_s_h_N_o_d_e_U_p. This event is sent whenever a node (where an
         MRP is residing), comes up again after having been down.
         The _e_x_t_r_a field in  the  event  contains  the  following
         information:
          {_N_o_d_e_N_a_m_e, _C_o_n_n_e_c_t_i_o_n_T_i_m_e}.

       * _m_e_s_h_N_o_d_e_D_o_w_n. This event is sent whenever a node  (where
         an  MRP  is  residing),goes down. The _e_x_t_r_a field in the
         event contains the following information:
          {_N_o_d_e_N_a_m_e, _C_r_a_s_h_T_i_m_e}.

       * _m_e_s_h_T_y_p_e_U_n_c_o_n_n_e_c_t_e_d. This event is sent when the  status
         of an MRP is indeterminate, for example when the connec-
         tion to the corresponding node has  been  lost,  but  no
         crash  report  has been received. The _e_x_t_r_a field in the
         event contains the following information:
          {_T_y_p_e_I_d, _n_o_d_e_d_o_w_n, _T_i_m_e}.

       * _m_e_s_h_M_e_a_s_u_r_e_m_e_n_t_U_n_c_o_n_n_e_c_t_e_d. This event is sent when  the
         status  of  a  measurement  object is indeterminate, for
         example when the connection to  the  corresponding  node
         has  been  lost,  but no crash report has been received.
         The _e_x_t_r_a field in  the  event  contains  the  following
         information:
          {_M_e_a_s_I_d, _T_y_p_e_I_d, _n_o_d_e_d_o_w_n, _T_i_m_e}.




Ericsson Utvecklings ALBast change: mesh  1.1.0                   6






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



       * _m_e_s_h_T_y_p_e_C_o_n_n_e_c_t_e_d. This event is sent when a  previously
         unconnected  MRP  reconnects.  For  example, if the node
         where the MRP had resided is reconnected, and the MRP is
         found  to still be present. The _e_x_t_r_a field in the event
         contains the following information:
          {_T_y_p_e_I_d, _n_o_d_e_u_p, _C_o_n_n_e_c_t_i_o_n_T_i_m_e}.

       * _m_e_s_h_M_e_a_s_u_r_e_m_e_n_t_C_o_n_n_e_c_t_e_d. This event is sent when a pre-
         viously  unconnected  measurement object reconnects. For
         example,  if  the  node  where  the  measurement  object
         resided  is  reconnected,  and the measurement object is
         found to still be present. The _e_x_t_r_a field in the  event
         contains the following information:
          {_M_e_a_s_I_d, _T_y_p_e_I_d, _n_o_d_e_u_p, _C_o_n_n_e_c_t_i_o_n_T_i_m_e}.

       * _m_e_s_h_M_e_a_s_u_r_e_m_e_n_t_R_e_p_o_r_t. This event is sent  whenever  the
         Measurement  Handler  receives a measurement report from
         any measurement object. The _e_x_t_r_a  field  in  the  event
         contains the following information:
          {{_n_a_m_e,  _M_e_a_s_I_d},  {_v_a_l_u_e,  _n_u_m_b_e_r()},  {_t_i_m_e,   _T_i_m_e},
         {_i_n_f_o, _M_e_a_s_I_n_f_o}}.

Adaptations
     The Mesh services are management protocol independent.  How-
     ever,  for  a manager to access the Mesh services, a manage-
     ment protocol is required, ie. _a_d_a_p_t_a_t_i_o_n_s must be  written,
     mapping Mesh services to the desired protocol.

EXPORTS
     create_tables(NodeList) -> Result

          Types
               NodeList = [NodeName]
               NodeName = atom()
               Result = ok | {error, Reason}
               Reason = term()

          Creates the Mnesia tables the Mesh  application  needs,
          with  disc  and RAM replicas on every node specified in
          _N_o_d_e_L_i_s_t.
           This function will only be called once, before  start-
          ing the Mesh application.

          Note: it is important that the schema created  is  con-
          sistent with the specified list of nodes.

     register_type(TypeId,  Extra,  InterfaceMod,   NofInst)   ->
     Result
     register_type(TypeId, Extra, InterfaceMod,  NofInst,  Admin-
     State) -> Result

          Types



Ericsson Utvecklings ALBast change: mesh  1.1.0                   7






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



               TypeId = atom()
               Extra = term()
               InterfaceMod = atom()
               NofInst = integer()
               AdminState = unlocked | shutting_down | locked
               Result =  {registered,  TypeId}  |  {reregistered,
               TypeId} | {error, Reason}
               Reason = term()

          This function registers (or reregisters) a  measurement
          type  in  the  Measurement Handler. The main purpose of
          this function is to associate the  _I_n_t_e_r_f_a_c_e_M_o_d  inter-
          face  module  with the _T_y_p_e_I_d identifier. (It should be
          noted that the  _T_y_p_e_I_d  identifier  cannot  be  reused,
          since  it  solely  identifies  a  measurement type, and
          therefore must be unique.)
           The _E_x_t_r_a argument is used  for  the  benefit  of  the
          user,  ie.  it  must contain all information describing
          the measurement type, but this information will only be
          used  by  the manager and never forwarded to any MRP or
          measurement object.
           The registration function will also  call  the  _i_n_i_t/_1
          function  in the interface module, thereby enabling the
          user to perform necessary  initializations.  (The  init
          function may, for example, start a MRP.)
           The _N_o_f_I_n_s_t parameter sets the measurement type  capa-
          city,  i.e., the number of measurement objects (belong-
          ing to the specified  measurement  type)  that  may  be
          created.
           The _A_d_m_i_n_S_t_a_t_e sets the initial  administrative  state
          of the the measurement type.

          It is possible to re-register a measurement type,  _p_r_o_-
          _v_i_d_e_d _t_h_a_t _t_h_e _s_a_m_e _i_n_t_e_r_f_a_c_e _m_o_d_u_l_e _i_s _s_p_e_c_i_f_i_e_d. This
          allows changes in capacity, e.g., the number  of  meas-
          urement objects that may be created.
           However, in the case of a capacity decrease, no  meas-
          urement  objects will be disabled, but an alarm will be
          sent to EVA.
           When re-registration has been approved  by  Mesh,  the
          _i_n_i_t/_1 function in the interface module will once again
          be called to restart possible existing MRPs.

          Should the type capacity be exceeded, a _m_e_s_h_T_y_p_e_C_a_p_a_c_i_-
          _t_y_E_x_c_e_e_d_e_d  alarm  will be sent to EVA. Once the number
          of existing measurement objects falls  below  the  type
          capacity, the alarm will be cleared.

     unregister_type(TypeId) -> Result
     unregister_type(TypeId, StopArgs) -> Result

          Types



Ericsson Utvecklings ALBast change: mesh  1.1.0                   8






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



               TypeId = atom()
               StopArgs = [term()]
               Result = {unregistered, TypeId} | {error, Reason}
               Reason = term()

          This function unregisters a  measurement  type  in  the
          Measurement  Handler.  Any existing measurement objects
          will be deleted,  and  the  interface  module  will  no
          longer  be  associated  with the _T_y_p_e_I_d identifier. For
          each     existing     measurement      object,      the
          _d_e_l_e_t_e__m_e_a_s_u_r_e_m_e_n_t/_3  function  in the measurement type
          interface will be called, with _S_t_o_p_A_r_g_s as one  of  the
          arguments.  Finally,  the  _t_e_r_m_i_n_a_t_e_1  function  in the
          measurement type interface will be called; this  is  to
          enable clean-up actions.
           _N_o_t_e:  The  _S_t_o_p_A_r_g_s  are  only  passed  on   to   the
          _d_e_l_e_t_e__m_e_a_s_u_r_e_m_e_n_t function, not to the _t_e_r_m_i_n_a_t_e func-
          tion!

     list_types() -> Result

          Types
               Result = [TypeInfo] | {error, Reason}
               TypeInfo    =    {TypeId,     [{extra,     Extra},
               {interface_mod, InterfaceMod}, {instances, CurrNo-
               fInst},        {max_instances,        MaxNofInst},
               {administrative_state, CurrAdminState}]}
               TypeId = atom()
               Extra = term()
               InterfaceMod = atom()
               CurrNofInst = integer()
               MaxNofInst = integer()
               CurrAdminState = unlocked | shutting_down | locked
               Reason = term()

          This function lists all the measurement types currently
          registered in the Measurement Handler, including infor-
          mation about settings and the current state of each  of
          the types.

     lock_type(TypeId) -> Result
     lock_type(TypeId, StopArgs) -> Result

          Types
               TypeId = atom()
               StopArgs = [term()]
               Result = {locked, TypeId} | {error, Reason}
               Reason = term()

          This function locks the specified measurement type, ie.
          prevents further usage until it becomes unlocked. After
          locking the measurement type, it will be impossible  to



Ericsson Utvecklings ALBast change: mesh  1.1.0                   9






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          create  any new measurement objects, and existing meas-
          urement   objects   will   be   deleted,   using    the
          _d_e_l_e_t_e__m_e_a_s_u_r_e_m_e_n_t/_3  function  in the measurement type
          interface; the _S_t_o_p_A_r_g_s  will  be  passed  on  to  this
          latter  function,  thereby  enabling  soft  measurement
          object termination. (Unless otherwise stated,  _S_t_o_p_A_r_g_s
          will be set to the empty list.)

     unlock_type(TypeId) -> Result

          Types
               TypeId = atom()
               Result = {unlocked, TypeId} | {error, Reason}
               Reason = term()

          This function unlocks the specified  measurement  type.
          Once  activated,  it  is possible to create measurement
          objects  (provided  that  the  type  capacity  is   not
          exceeded).

     shut_down_type(TypeId) -> Result

          Types
               TypeId = atom()
               Result  =  {shutting_down,  TypeId}   |   {locked,
               TypeId} | {error, Reason}
               Reason = term()

          This function  shuts  down  the  specified  measurement
          type.  Once  effective,  no  measurement objects can be
          created and measurement objects cannot be revived, once
          they have been disabled.
           Existing measurement objects are allowed  to  continue
          to  exist,  but once all measurement objects (belonging
          to the specified type) have been disabled  or  deleted,
          the measurement type is automatically locked.

     create_measurement(MeasId, TypeId, Extra, ResId) -> Result
     create_measurement(MeasId, TypeId, Extra, ResId, AdminState)
     -> Result
     create_measurement(MeasId, TypeId, Extra, ResId, AdminState,
     StartArgs) -> Result

          Types
               MeasId = atom()
               TypeId = atom()
               Extra = term()
               ResId = term()
               AdminState = started | stopped
               StartArgs = [term()]
               Result = {created, MeasId} | {error, Reason}




Ericsson Utvecklings ALBast change: mesh  1.1.0                  10






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          This function creates a new measurement object  belong-
          ing  to  the  specified  measurement type, provided the
          type capacity is not exceeded. The _c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t/_5
          function  in  the  type  interface will be called, with
          some of the supplied arguments, as  a  result  of  this
          function call. Please see below, and the section relat-
          ing to _I_n_t_e_r_f_a_c_e _M_o_d_u_l_e _F_u_n_c_t_i_o_n_s.
           The _M_e_a_s_I_d identifier,  during  the  lifetime  of  the
          object,  is  used  to  uniquely identify the object. It
          follows that there can only be one  measurement  object
          with a unique measurement identifier.
           The _T_y_p_e_I_d identifier tells the measurement type which
          interface  module  to  use when creating the object and
          communicating with it; the  _T_y_p_e_I_d  identifier  is  the
          same  as  was  given  when  the  measurement  type  was
          registered.
           The _E_x_t_r_a argument is any additional information about
          the measurement object the user chooses to supply; this
          information is _n_o_t forwarded to the measurement  object
          itself.
           The _R_e_s_I_d argument is any term telling the  new  meas-
          urement  object which resources to use; the interpreta-
          tion of this term is solely a user issue!
           The _A_d_m_i_n_S_t_a_t_e tells the original administrative state
          of the new measurement object, ie. whether it should be
          _s_t_a_r_t_e_d or _s_t_o_p_p_e_d. The default administrative state is
          _s_t_a_r_t_e_d.
           _S_t_a_r_t_A_r_g_s is any list of terms the user wants to  for-
          ward  to the new measurement object as start arguments,
          setting the original state, eg. the  sampling  interval
          and  the  algorithm, to use when evaluating samples are
          collected. Unless specified by the user, _S_t_a_r_t_A_r_g_s will
          be set to the empty list when forwarded to the measure-
          ment object.

          _N_o_t_e: the _S_t_a_r_t_A_r_g_s list has to have the same format in
          the functions _c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t, _s_t_a_r_t__m_e_a_s_u_r_e_m_e_n_t and
          _r_e_s_e_t__m_e_a_s_u_r_e_m_e_n_t,  see  the  description  of  function
          _r_e_v_i_v_e__m_e_a_s_u_r_e_m_e_n_t for further information.

     delete_measurement(MeasId) -> Result
     delete_measurement(MeasId, StopArgs) -> Result

          Types
               MeasId = atom()
               StopArgs = [term()]
               Result = {deleted, MeasId} | {error, Reason}

          This function deletes the specified measurement object.
          As    a    result    of   this   function   call,   the
          _d_e_l_e_t_e__m_e_a_s_u_r_e_m_e_n_t/_3 function in the  measurement  type
          interface  will  be  called,  with some of the supplied



Ericsson Utvecklings ALBast change: mesh  1.1.0                  11






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          arguments.  Please  see  below  and  section  _I_n_t_e_r_f_a_c_e
          _M_o_d_u_l_e _F_u_n_c_t_i_o_n_s for further information.
           _M_e_a_s_I_d is the measurement identifier used to  identify
          the measurement object.
           _S_t_o_p_A_r_g_s is any list of terms the user wants  to  for-
          ward to the measurement object, thereby enabling a soft
          termination; the default is the empty list.
           _N_o_t_e: it is the responsibility of the user  to  ensure
          that  all  resources and applications used by the meas-
          urement object are terminated and/or freed  in  a  con-
          trolled manner when an object is terminated.

     measurement_terminated(MeasId, Reason) -> ok

          Types
               MeasId = atom()
               Reason = term()

          This function is used to inform the Measurement Handler
          about  terminated/disabled  measurement  objects. Since
          the Measurement Handler only supervises the Measurement
          Responsible  Processes (MRPs), it is strictly necessary
          that each MRP reports to Mesh about terminated/disabled
          measurement  objects.  The operation of the Measurement
          Handler is not guaranteed, should the MRPs neglect this
          reporting.
           Should the measurement object itself be  an  MRP,  not
          supervising any other measurement objects, the Measure-
          ment Handler will notice  automatically  (since  it  is
          linked  to  each  MRP)  if  the measurement object ter-
          minates, and no specific reporting is  needed  in  this
          case.  In  all  other  cases  the MRPs _m_u_s_t report each
          measurement object  termination  to  Mesh,  using  this
          function.

     list_measurements(TypeId) -> Result

          Types
               TypeId = atom()
               Result = [MeasInfo] | {error, Reason}
               MeasInfo = {MeasId, [{extra,  Extra},  {resources,
               ResId},       {initial_arguments,      StartArgs},
               {operability_state,                CurrOperState},
               {administrative_state, CurrAdminState}]}
               MeasId = atom()
               Extra = term()
               ResId = term()
               StartArgs = [term()]
               CurrOperState = enabled | disabled
               CurrAdminState = started | stopped
               Reason = term()




Ericsson Utvecklings ALBast change: mesh  1.1.0                  12






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          This function lists all measurement  objects  belonging
          to the specified measurement type. The listing includes
          information about the resources used, the initial state
          (ie. the last known start arguments), the current oper-
          ability state (ie. whether the  measurement  object  is
          enabled or disabled), and the administrative state (ie.
          whether the measurement object is started or stopped).

          _N_o_t_e: the _S_t_a_r_t_A_r_g_s is the list of start  arguments  as
          given   in  any  (ie.  the  latest)  of  the  functions
          _c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t,        _s_t_a_r_t__m_e_a_s_u_r_e_m_e_n_t        and
          _r_e_s_e_t__m_e_a_s_u_r_e_m_e_n_t.

     revive_measurement(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {revived, MeasId} | {error, Reason}
               Reason = term()

          This function tries to revive  a  disabled  measurement
          object,  using  the  last known settings, including set
          thresholds.

          Please noted that the last known start  arguments  will
          be  used  when  trying  to revive a measurement object.
          These start arguments consist of the latest known _S_t_a_r_-
          _t_A_r_g_s  list; this list may be specified in any of these
          three function calls:

            * create_measurement

            * start_measurement

            * reset_measurement

          Therefore, the _S_t_a_r_t_A_r_g_s list must have the same format
          in these three functions.

          The last step in the revival procedure,  resetting  the
          measurement  object,  is ordered by Mesh to ensure con-
          sistent states in the Measurement Handler and the meas-
          urement object.

     start_measurement(MeasId) -> Result
     start_measurement(MeasId, StartArgs) -> Result

          Types
               MeasId = atom()
               StartArgs = [term()]
               Result = {started, MeasId} | {error, Reason}
               Reason = term()



Ericsson Utvecklings ALBast change: mesh  1.1.0                  13






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          This function orders a specified measurement object  to
          start  running  (ie.  to  enter  a working state). As a
          result of this function call,  the  _s_t_a_r_t__m_e_a_s_u_r_e_m_e_n_t/_3
          function  in  the  measurement  type  interface will be
          called, with some of the supplied arguments. Please see
          below   and  section  _I_n_t_e_r_f_a_c_e  _M_o_d_u_l_e  _F_u_n_c_t_i_o_n_s  for
          further information. No resetting takes place, with the
          exception  of  thresholds set: if previously triggered,
          they are  restored  to  an  un-triggered  state.  (This
          applies  only  to  the Measurement Handler, if the user
          has implemented thresholds in the  measurement  object,
          it  is  their own responsibility to ensure they are set
          to a consistent state.)

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _S_t_a_r_t_A_r_g_s is any list of terms the user wants to  for-
          ward  to  the  measurement object, thereby changing its
          internal state. The default is set to the empty list.


          _N_o_t_e: the _S_t_a_r_t_A_r_g_s list must have the same  format  in
          the functions _c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t, _s_t_a_r_t__m_e_a_s_u_r_e_m_e_n_t and
          _r_e_s_e_t__m_e_a_s_u_r_e_m_e_n_t,  see  the  description  of  function
          _r_e_v_i_v_e__m_e_a_s_u_r_e_m_e_n_t for further information.

     stop_measurement(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {stopped, MeasId} | {error, Reason}
               Reason = term()

          This function orders the specified  measurement  object
          to  stop  running  and become idle. As a result of this
          function call, the _s_t_o_p__m_e_a_s_u_r_e_m_e_n_t/_2 function  in  the
          measurement  type  interface will be called, please see
          section _I_n_t_e_r_f_a_c_e _M_o_d_u_l_e _F_u_n_c_t_i_o_n_s. No resetting  takes
          place  in  the  Measurement Handler, and all thresholds
          set remain set. However, no measurement reports will be
          accepted from a stopped measurement object.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.


     reset_measurement(MeasId) -> Result
     reset_measurement(MeasId, StartArgs) -> Result

          Types
               MeasId = atom()
               StartArgs = [term()]



Ericsson Utvecklings ALBast change: mesh  1.1.0                  14






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



               Result = {reset, MeasId} | {error, Reason}
               Reason = term()

          This function orders the specified  measurement  object
          to reset its internal state, and resets in the Measure-
          ment Handler all measurement information  stored  about
          the  measurement object. All thresholds set will remain
          set, but if previously triggered, they are restored  to
          an un-triggered state.
           As   a   result   of   this   function    call,    the
          _r_e_s_e_t__m_e_a_s_u_r_e_m_e_n_t/_2  function  in  the measurement type
          interface will be called, please see section  _I_n_t_e_r_f_a_c_e
          _M_o_d_u_l_e _F_u_n_c_t_i_o_n_s.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _S_t_a_r_t_A_r_g_s is any list of terms the user wants to  for-
          ward  to  the  measurement object, thereby changing its
          internal state. Default is set to the empty list.


          _N_o_t_e: the _S_t_a_r_t_A_r_g_s list has to have the same format in
          the functions _c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t, _s_t_a_r_t__m_e_a_s_u_r_e_m_e_n_t and
          _r_e_s_e_t__m_e_a_s_u_r_e_m_e_n_t,  see  the  description  of  function
          _r_e_v_i_v_e__m_e_a_s_u_r_e_m_e_n_t for further information.

     measurement_report(MeasId, Value, TimeStamp) -> ok
     measurement_report(MeasId, Value, TimeStamp, MeasInfo) -> ok

          Types
               MeasId = atom()
               Value = number()
               TimeStamp = term()
               MeasInfo = term()

          This function is used to report  a  measurement  value,
          obtained  by any measurement object, to the Measurement
          Handler. The Measurement Handler will update the  tide-
          marks  and compare the received value to the thresholds
          set, and when required, forward the measurement  report
          to  EVA.  The  measurement  value  will  also be stored
          (internally) in the Measurement Handler,  until  a  new
          measurement  report  is received from the same measure-
          ment object.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _V_a_l_u_e is the measurement value the measurement  object
          has obtained.
           _T_i_m_e_S_t_a_m_p is any (user specified) term describing  the
          time  and  date the measurement value and/or report was
          obtained or sent.



Ericsson Utvecklings ALBast change: mesh  1.1.0                  15






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



           _M_e_a_s_I_n_f_o is any (user specified) term  describing  the
          measurement  report  and/or providing extra information
          to the manager.

     get_measurement_report(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {MeasId, Value,  TimeStamp,  MeasInfo}  |
               {error, Reason}
               Value = number()
               TimeStamp = term()
               MeasInfo = term()
               Reason = term

          This function gets the most recently reported  measure-
          ment value from a specified measurement object.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _V_a_l_u_e is the measurement value reported by  the  meas-
          urement object.
           _T_i_m_e_S_t_a_m_p is any (user specified) term describing  the
          time  and  date the measurement value and/or report was
          obtained or sent.
           _M_e_a_s_I_n_f_o is any (user specified) term  describing  the
          measurement  report  and/or providing extra information
          to the manager.

     set_upper_threshold(MeasId, ThreshId, Value) -> Result
     set_upper_threshold(MeasId,  ThreshId,  Value,  Status)   ->
     Result

          Types
               MeasId = atom()
               ThreshId = atom()
               Value = number() | {ValueHi, ValueLo}
               ValueHi = ValueLo = number()
               Status = enabled | disabled
               Result =  {threshold_set,  {MeasId,  ThreshId}}  |
               {error, Reason}
               Reason = term()

          This function sets an upper threshold in  the  Measure-
          ment  Handler. Thus, when a threshold has been exceeded
          an alarm will be triggered. The  specified  measurement
          object  also  receives the threshold information, using
          the     measurement     type     interface     function
          _s_e_t__u_p_p_e_r__t_h_r_e_s_h_o_l_d/_5,  to  allow the user to implement
          the threshold functionality on their own.  However,  it
          should  be  noted that the _s_e_t__u_p_p_e_r__t_h_r_e_s_h_o_l_d function
          in the measurement type interface is  purely  optional.



Ericsson Utvecklings ALBast change: mesh  1.1.0                  16






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          The  Measurement  Handler  will  not  crash, should the
          function not be present, because, Mesh will  not  check
          the return value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_h_r_e_s_h_I_d is the threshold identifier,  which  is  used
          _t_o_g_e_t_h_e_r  with  the  measurement identifier to uniquely
          identify a threshold. Therefore, two different measure-
          ment objects may use the same threshold identifier.
           _V_a_l_u_e is a single number or a pair of numbers,  speci-
          fying  the  threshold  level.  In the case of a pair of
          numbers, the first one is assumed to specify the  level
          (value)  any  measurement  value has to exceed in order
          for the threshold to be triggered. The second number is
          the  value  any  measurement value has to fall below in
          order  for  a  previously  triggered  threshold  to  be
          cleared (untriggered).
           If only one value is given, the two levels are assumed
          to be the same.
           _S_t_a_t_u_s specifies whether the threshold will be enabled
          or  disabled  when created. Only enabled thresholds can
          be triggered.

          A triggered threshold will issue  a  _m_e_s_h_T_h_r_e_s_h_o_l_d_T_r_i_g_-
          _g_e_r_e_d  alarm to EVA. When the threshold becomes untrig-
          gered, the alarm is cleared.

     set_lower_threshold(MeasId, ThreshId, Value) -> Result
     set_lower_threshold(MeasId,  ThreshId,  Value,  Status)   ->
     Result

          Types
               MeasId = atom()
               ThreshId = atom()
               Value = number() | {ValueLo, ValueHi}
               ValueHi = ValueLo = number()
               Status = enabled | disabled
               Result =  {threshold_set,  {MeasId,  ThreshId}}  |
               {error, Reason}
               Reason = term()

          This function sets a lower threshold in the Measurement
          Handler.  Therefore, an obtained measurement value must
          fall below the lower threshold in order for the  thres-
          hold  alarm  to be triggered. The specified measurement
          object also receives the threshold  information,  using
          the     measurement     type     interface     function
          _s_e_t__l_o_w_e_r__t_h_r_e_s_h_o_l_d/_5, should the user want  to  imple-
          ment the threshold functionality on their own. However,
          it should be noted that the  _s_e_t__l_o_w_e_r__t_h_r_e_s_h_o_l_d  func-
          tion  in  the  measurement  type  interface  is  purely



Ericsson Utvecklings ALBast change: mesh  1.1.0                  17






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          optional.  The  Measurement  Handler  will  not  crash,
          should  the function not be present, because, Mesh does
          not check the return value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_h_r_e_s_h_I_d is the threshold identifier,  which  is  used
          _t_o_g_e_t_h_e_r  with  the  measurement identifier to uniquely
          identify a threshold. Thus, two  different  measurement
          objects may use the same threshold identifier.
           _V_a_l_u_e is a single number or a pair of numbers,  speci-
          fying  the  threshold  level.  In the case of a pair of
          numbers, the first one is assumed to specify the  level
          (value)  any  measurement  value  has  to fall below in
          order for the threshold to  be  triggered.  The  second
          number is the value any measurement value has to exceed
          in order for a previously  triggered  threshold  to  be
          cleared (untriggered).
           If only one value is given, the two levels are assumed
          to be the same.
           _S_t_a_t_u_s specifies whether the threshold will be enabled
          or  disabled  when created. Only enabled thresholds can
          be triggered.

          A triggered threshold will  activate  a  _m_e_s_h_T_h_r_e_s_h_o_l_d_-
          _T_r_i_g_g_e_r_e_d  alarm  to  EVA.  When  the threshold becomes
          untriggered, the alarm is cleared.

     remove_threshold(MeasId, ThreshId) -> Result

          Types
               MeasId = atom()
               ThreshId = atom()
               Result = {threshold_removed, {MeasId, ThreshId}} |
               {error, Reason}
               Reason = term()

          This function removes a specified  threshold  from  the
          specified measurement object. The specified measurement
          object also receives the threshold removal  order,  via
          the     measurement     type     interface     function
          _r_e_m_o_v_e__t_h_r_e_s_h_o_l_d/_3, should the user want  to  implement
          the  threshold  functionality  on  his own. However, it
          should be noted that the _r_e_m_o_v_e__t_h_r_e_s_h_o_l_d  function  in
          the  measurement type interface is purely optional. The
          Measurement Handler will not crash, should the function
          not  be present because, Mesh does not check the return
          value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_h_r_e_s_h_I_d is the threshold identifier,  which  is  used



Ericsson Utvecklings ALBast change: mesh  1.1.0                  18






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          _t_o_g_e_t_h_e_r  with  the  measurement identifier to uniquely
          identify a threshold.

     remove_thresholds(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {thresholds_removed,  MeasId}  |  {error,
               Reason}
               Reason = term()

          This function removes all existing thresholds from  the
          specified measurement object. The specified measurement
          object also receives the threshold removal  order,  via
          (repetitive  calls  to)  the measurement type interface
          function _r_e_m_o_v_e__t_h_r_e_s_h_o_l_d/_3, should the  user  want  to
          implement  the  threshold  functionality  on their own.
          However, it should be noted that  the  _r_e_m_o_v_e__t_h_r_e_s_h_o_l_d
          function  in  the  measurement type interface is purely
          optional.  The  Measurement  Handler  will  not  crash,
          should  the  function not be present because, Mesh will
          not even check the return value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.

     list_thresholds(MeasId) -> Result

          Types
               MeasId = atom()
               Result     =      {MeasId,      {upper_thresholds,
               [ThreshInfo]}, {lower_thresholds, [ThreshInfo]}} |
               {error, Reason}
               ThreshInfo = {ThreshId, Status, Value}
               ThreshId = atom()
               Status = enabled | disabled
               Value = number() | {number(), number()}
               Reason = term()

          This function lists all existing thresholds set for the
          specified   measurement   object.  The  thresholds  are
          divided into the two categories  _u_p_p_e_r  _t_h_r_e_s_h_o_l_d_s  and
          _l_o_w_e_r  _t_h_r_e_s_h_o_l_d_s.  For  each  threshold,  the  current
          status is specified (_e_n_a_b_l_e_d or _d_i_s_a_b_l_e_d), as  well  as
          the threshold value(s) set.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.

     enable_threshold(MeasId, ThreshId) -> Result

          Types



Ericsson Utvecklings ALBast change: mesh  1.1.0                  19






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



               MeasId = atom()
               ThreshId = atom()
               Result = {threshold_enabled, {MeasId, ThreshId}} |
               {error, Reason}
               Reason = term()

          This function enables  the  specified  threshold.  Only
          enabled  thresholds  may  be  triggered.  The specified
          measurement object also receives the  enable  threshold
          order,  via  the  measurement  type  interface function
          _e_n_a_b_l_e__t_h_r_e_s_h_o_l_d/_3, should the user want  to  implement
          the  threshold  functionality  on  his own. However, it
          should be noted that the _e_n_a_b_l_e__t_h_r_e_s_h_o_l_d  function  in
          the  measurement type interface is purely optional. The
          Measurement Handler will not crash, should the function
          not  be  present  because, Mesh will not even check the
          return value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_h_r_e_s_h_I_d is the threshold identifier,  which  is  used
          _t_o_g_e_t_h_e_r  with  the  measurement identifier to uniquely
          identify a threshold.

     disable_threshold(MeasId, ThreshId) -> Result

          Types
               MeasId = atom()
               ThreshId = atom()
               Result = {threshold_disabled, {MeasId,  ThreshId}}
               | {error, Reason}
               Reason = term()

          This function disables a specified threshold.  Disabled
          thresholds  cannot be triggered. The specified measure-
          ment object also receives the disable threshold  order,
          via    the    measurement   type   interface   function
          _d_i_s_a_b_l_e__t_h_r_e_s_h_o_l_d/_3, should the user want to  implement
          the  threshold  functionality  on  his own. However, it
          should be noted that the _d_i_s_a_b_l_e__t_h_r_e_s_h_o_l_d function  in
          the  measurement  type interface is purely optional The
          Measurement Handler will not crash, should the function
          not  be  present  because, Mesh will not even check the
          return value.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_h_r_e_s_h_I_d is the threshold identifier,  which  is  used
          _t_o_g_e_t_h_e_r  with  the  measurement identifier to uniquely
          identify a threshold.





Ericsson Utvecklings ALBast change: mesh  1.1.0                  20






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



     report_tidemarks(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {MeasId,  TypeId,  MaxTideMark,  MinTide-
               Mark} | {error, Reason}
               TypeId = atom()
               MaxTideMark    =     {max_tidemark,     [{current,
               CurrValue},  {previous, PrevValue}, {reset, Reset-
               Time}]}
               MinTideMark    =     {min_tidemark,     [{current,
               CurrValue},  {previous, PrevValue}, {reset, Reset-
               Time}]}
               CurrValue = PrevValue = number()
               ResetTime = {Date, Time}
               Date = {Year, Month, Day}
               Time = {Hour, Minute, Second}
               Year = Month = Day = Hour  =  Minute  =  Second  =
               int()
               Reason = term()

          This function reports the current values of the maximum
          and  minimum  tide-marks  associated with the specified
          measurement object.
           Each tide-mark contains the maximum (or minimum) value
          reached  since  the  last time the tide-mark was reset,
          and also the maximum (or minimum) value reached in  the
          period prior to the last reset.

          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.
           _T_y_p_e_I_d is the measurement type identifier.

          Note: the time is given using the Universal Coordinated
          Time  time  zone (sometimes denoted Greenwich Mean Time
          or GMT).

     reset_tidemarks(MeasId) -> Result

          Types
               MeasId = atom()
               Result = {tidemarks_reset, MeasId} | {error,  Rea-
               son}
               Reason = term()

          This function resets the maximum and minimum tide-marks
          associated  with a specified measurement object. Reset-
          ting consists of storing the current value as the  pre-
          vious  current  value, replacing the current value with
          the atom 'undefined', and noting the reset time.





Ericsson Utvecklings ALBast change: mesh  1.1.0                  21






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          _M_e_a_s_I_d is the measurement identifier used  to  identify
          the measurement object.


     watchdog_setup(NofTypes, NofMeas) -> Result

          Types
               NofTypes = NofMeas = int()
               Result = ok | {error, Reason}
               Reason = term()

          This functions handles the set-up  of  the  Measurement
          Handler  watchdog.  The  purpose  of the watchdog is to
          keep track of the _t_o_t_a_l  number  of  measurement  types
          registered,  as well as the total number of measurement
          objects created. Should the number of types exceed  the
          number  specified  using this function, the alarm _m_e_s_h_-
          _T_o_o_M_a_n_y_T_y_p_e_s is sent to EVA, however, the  alarm  _m_e_s_h_-
          _T_o_o_M_a_n_y_M_e_a_s_u_r_e_m_e_n_t_s  is  sent  if the number of allowed
          measurement objects is exceeded.
           It should be noted that the  alarms  issued  are  just
          warnings and it is still possible to register new meas-
          urement types,  and  also  to  create  new  measurement
          objects  (provided that the associated measurement type
          capacity is not exceeded).

Functions used to control the various
     Mesh uses three logs:

       * _a_l_a_r_m_s are logged in the _m_e_s_h__a_l_a_r_m_s log.

       * _e_v_e_n_t_s are logged in the _m_e_s_h__e_v_e_n_t_s log.

       * _m_e_a_s_u_r_e_m_e_n_t _r_e_p_o_r_t_s are logged in the  _m_e_s_h__m_e_a_s_u_r_e_m_e_n_t_s
         log.

     The user may freely choose to replace  the  filter  function
     used  by  each  log,  using  a  user defined filter function
     instead, or to restore the original filter function.

EXPORTS
     set_alarm_filter(Func) -> Result

          Types
               Func = {Mod, Fcn, Args}
               Mod = Fcn = atom()
               Args = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function replaces the default filter with the user
          specified. (The default filter ensures that only alarms



Ericsson Utvecklings ALBast change: mesh  1.1.0                  22






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          are recorded in this log,  but  does  not  perform  any
          other action.)

     set_event_filter(Func) -> Result

          Types
               Func = {Mod, Fcn, Args}
               Mod = Fcn = atom()
               Args = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function replaces the default filter with  a  user
          specified  filter. The default filter ensures that only
          events,  with  the  exception  of  measurement   report
          events,  are  logged  in this log, but will not perform
          any other action.

     set_measurement_filter(Func) -> Result

          Types
               Func = {Mod, Fcn, Args}
               Mod = Fcn = atom()
               Args = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function replaces the default filter with the user
          specified  filter. The default filter ensures that only
          measurement report events are recorded in this log, but
          will not perform any other action.

     reset_alarm_filter() -> Result

          Types
               Result = ok | {error, Reason}
               Reason = term()

          This function restores the filter used to  the  default
          one.

     reset_event_filter() -> Result

          Types
               Result = ok | {error, Reason}
               Reason = term()

          This function restores the filter used to  the  default
          one.

     reset_measurement_filter() -> Result




Ericsson Utvecklings ALBast change: mesh  1.1.0                  23






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          Types
               Result = ok | {error, Reason}
               Reason = term()

          This function restores the filter used to  the  default
          one.

Interface Module Functions
     The Measurement Handler application calls a number of  func-
     tions  in  each  _m_e_a_s_u_r_e_m_e_n_t  _t_y_p_e _i_n_t_e_r_f_a_c_e module. Only if
     explicitly stated below is it optional to export a  specific
     function.
      The absence of a required function will not cause the Meas-
     urement  Handler  to  crash,  but it will severely limit the
     possibilities when handling  the  corresponding  measurement
     types and measurement objects.

EXPORTS
     InterfaceMod:init(TypeId) -> Result

          Types
               TypeId = atom()
               Result = MRP | {error, Reason}
               MRP = pid() | undefined
               Reason = term()

          This  function  takes  care  of  the  user  application
          specific initialization. Should there be an MRP respon-
          sible for a number of measurement objects, it has to be
          started  by this function, in which case the PID of the
          MRP will have the return value of the function.  If  no
          MRP is started, the atom 'undefined' will be returned.

     InterfaceMod:terminate(MRP) -> Result

          Types
               MRP = pid() | undefined
               Result = ok | {error, Reason}
               Reason = term()

          This function is responsible for user specific termina-
          tion  and  clean-up.  If  resources  have  to be freed,
          and/or applications terminated, this  function  has  to
          handle it.

          The _M_R_P argument is the identifier once  returned  from
          the _I_n_t_e_r_f_a_c_e_M_o_d:_i_n_i_t function.

     InterfaceMod:create_measurement(MRP1, TypeId, MeasId, ResId,
     StartArgs) -> Result

          Types



Ericsson Utvecklings ALBast change: mesh  1.1.0                  24






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



               MRP1 = pid() | undefined
               TypeId = atom()
               MeasId = atom()
               ResId = term()
               StartArgs = [term()]
               Result = MRP2 | {error, Reason}
               MRP2 = pid()
               Reason = term()

          This function handles the actual creation of a measure-
          ment  object.  It  is the user's responsibility to make
          sure  that  the  created  object   uses   the   correct
          resources, and performs measurements as intended.

          The _M_R_P_1 argument is the identifier once returned  from
          the  _I_n_t_e_r_f_a_c_e_M_o_d:_i_n_i_t function. This identifier may be
          a pid, or it may be the atom 'undefined'. However,  the
          return  value  of  the function has to be a PID, namely
          the process identifier of the process  supervising  the
          measurement  object (which actually may be the measure-
          ment object itself).

     InterfaceMod:start_measurement(MRP,  MeasId,  StartArgs)  ->
     Result

          Types
               MRP = pid()
               MeasId = atom()
               StartArgs = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function handles a measurement object start.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

     InterfaceMod:stop_measurement(MRP, MeasId) -> Result

          Types
               MRP = pid()
               MeasId = atom()
               Result = ok | {error, Reason}
               Reason = term()

          This function handles a measurement object stop.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

     InterfaceMod:reset_measurement(MRP,  MeasId,  StartArgs)  ->
     Result



Ericsson Utvecklings ALBast change: mesh  1.1.0                  25






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          Types
               MRP = pid()
               MeasId = atom()
               StartArgs = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function is responsible for  the  resetting  of  a
          measurement object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

     InterfaceMod:delete_measurement(MRP,  MeasId,  StopArgs)  ->
     Result

          Types
               MRP = pid()
               MeasId = atom()
               StopArgs = [term()]
               Result = ok | {error, Reason}
               Reason = term()

          This function deletes the specified measurement object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

     InterfaceMod:set_upper_threshold(MRP,   MeasId,    ThreshId,
     Value, Status) -> Result

          Types
               MRP = pid()
               MeasId = atom()
               ThreshId = atom()
               Value = number() | {ValueHi, ValueLo}
               ValueHi = ValueLo = number()
               Status = enabled | disabled
               Result = ok | {error, Reason}
               Reason = term()

          This function sets an upper threshold in a  measurement
          object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

          _N_o_t_e: the existence of this function is optional!

     InterfaceMod:set_lower_threshold(MRP,   MeasId,    ThreshId,
     Value, Status) -> Result




Ericsson Utvecklings ALBast change: mesh  1.1.0                  26






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          Types
               MRP = pid()
               MeasId = atom()
               ThreshId = atom()
               Value = number() | {ValueLo, ValueHi}
               ValueLo = ValueHi = number()
               Status = enabled | disabled
               Result = ok | {error, Reason}
               Reason = term()

          This function sets a lower threshold in  a  measurement
          object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

          _N_o_t_e: the existence of this function is optional.

     InterfaceMod:remove_threshold(MRP,  MeasId,   ThreshId)   ->
     Result

          Types
               MRP = pid()
               MeasId = atom()
               ThreshId = atom()
               Result = ok | {error, Reason}
               Reason = term()

          This function removes a specified threshold in a  meas-
          urement object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

          _N_o_t_e: the existence of this function is optional.

     InterfaceMod:enable_threshold(MRP,  MeasId,   ThreshId)   ->
     Result

          Types
               MRP = pid()
               MeasId = atom()
               ThreshId = atom()
               Result = ok | {error, Reason}
               Reason = term()

          This function enables a specified threshold in a  meas-
          urement object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.




Ericsson Utvecklings ALBast change: mesh  1.1.0                  27






mesh(3)             ERLANG MODULE DEFINITION              mesh(3)



          _N_o_t_e: the existence of this function is optional.

     InterfaceMod:disable_threshold(MRP,  MeasId,  ThreshId)   ->
     Result

          Types
               MRP = pid()
               MeasId = atom()
               ThreshId = atom()
               Result = ok | {error, Reason}
               Reason = term()

          This function disables a specified threshold in a meas-
          urement object.

          The _M_R_P argument is the identifier  returned  from  the
          _I_n_t_e_r_f_a_c_e_M_o_d:_c_r_e_a_t_e__m_e_a_s_u_r_e_m_e_n_t function.

          _N_o_t_e: the existence of this function is optional.

SEE ALSO
     mesh_lib(3),  mesh_snmp(3),   application(3),   disk_log(3),
     eva(3), eva_log(3), eva_sup(3), mnesia(3)

AUTHOR
     Fredrik Gustafson - support@erlang.ericsson.se





























Ericsson Utvecklings ALBast change: mesh  1.1.0                  28



